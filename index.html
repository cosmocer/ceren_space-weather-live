<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Live Space Weather Dashboard</title>
  <style>
    :root{ --bg:#0b1220; --card:#121a2b; --muted:#8aa0c2; --text:#e7eefc; --accent:#5ec7ff; --warn:#ffd166; --alert:#ff6b6b; --ok:#7bd88f; }
    *{box-sizing:border-box}
    body{margin:0; font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; background:linear-gradient(180deg,#0b1220,#0a1326); color:var(--text)}
    header{padding:18px 20px; display:flex; align-items:center; justify-content:space-between; gap:12px; border-bottom:1px solid #1e2a45}
    header h1{font-size:18px; margin:0; letter-spacing:.3px}
    header .updated{font-size:12px; color:var(--muted)}
    .container{max-width:1200px; margin:0 auto; padding:18px}
    .grid{display:grid; grid-template-columns:repeat(12,1fr); gap:14px}
    .card{background:var(--card); border:1px solid #1e2a45; border-radius:14px; padding:14px; box-shadow:0 6px 20px rgba(0,0,0,.25)}
    .card h2{margin:0 0 8px; font-size:14px; color:#cfe1ff; font-weight:600}
    .value{font-size:28px; font-weight:700}
    .sub{font-size:12px; color:var(--muted)}
    .row{display:flex; gap:12px; flex-wrap:wrap; align-items:baseline}
    .chip{font-size:12px; padding:4px 8px; border-radius:999px; border:1px solid #28466e; color:#cfe1ff}
    .ok{color:var(--ok); border-color:rgba(123,216,143,.35)}
    .warn{color:var(--warn); border-color:rgba(255,209,102,.35)}
    .alert{color:var(--alert); border-color:rgba(255,107,107,.35)}
    .col-3{grid-column:span 3}
    .col-4{grid-column:span 4}
    .col-6{grid-column:span 6}
    .col-8{grid-column:span 8}
    .col-12{grid-column:span 12}

    canvas{width:100%; height:54px}
    #kp-chart{height:220px}

    .aurora{display:grid; grid-template-columns:1fr; gap:8px}
    .aurora img{width:100%; border-radius:12px; border:1px solid #1e2a45}

    #efield-map{width:100%; height:480px; border-radius:12px; border:1px solid #1e2a45; position:relative}
    .legend{background:rgba(18,26,43,.92); color:#cfe1ff; padding:8px 10px; border-radius:8px; border:1px solid #1e2a45; line-height:1.4}
    .legend .swatch{display:inline-block; width:12px; height:12px; margin-right:6px; vertical-align:middle; border-radius:3px}
    .inline-error{position:absolute; left:10px; top:10px; background:rgba(255,107,107,.15); color:#ff9f9f; padding:6px 8px; border:1px solid rgba(255,107,107,.35); border-radius:8px; font-size:12px; display:none; z-index:500}

    @media (max-width: 860px){ .col-3,.col-4,.col-6,.col-8{grid-column:span 12} header{flex-direction:column; align-items:flex-start} }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
  </style>
  <!-- Leaflet CSS/JS (load first) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
</head>
<body>
  <header>
    <h1>Live Space Weather</h1>
    <div class="updated" id="last-updated">Loading…</div>
  </header>
  <div class="container">
    <div class="grid">
      <!-- Row 1: Kp (left) and Alerts (right) top-aligned -->
      <section class="card col-3">
        <h2>Planetary Kp</h2>
        <div class="value" id="kp">—</div>
        <div class="sub" id="kp-time">—</div>
        <div class="row" id="kp-badges"></div>
      </section>

      <section class="card col-3" style="align-self:start">
        <h2>NOAA Watches/Warnings/Alerts</h2>
        <div id="alerts">Loading…</div>
        <div class="sub">Latest warning only. Source: <a href="https://www.swpc.noaa.gov/" target="_blank" rel="noopener">SWPC</a></div>
      </section>

      <!-- Keep other quick-look cards on this row -->
      <section class="card col-3">
        <h2>GOES X-ray Flux</h2>
        <div class="value" id="xray-class">—</div>
        <div class="sub" id="xray-time">—</div>
        <canvas id="xray-spark"></canvas>
        <div class="sub">Class scale: A < B < C < M < X</div>
      </section>

      <section class="card col-3">
        <h2>Solar Wind</h2>
        <div class="row">
          <div><div class="sub">Speed (km/s)</div><div class="value" id="sw-speed">—</div></div>
          <div><div class="sub">Density (cm⁻³)</div><div class="value" id="sw-density">—</div></div>
          <div><div class="sub">B<sub>z</sub> (nT)</div><div class="value" id="sw-bz">—</div></div>
          <div><div class="sub">B<sub>t</sub> (nT)</div><div class="value" id="sw-bt">—</div></div>
        </div>
        <div class="sub">Live L1 measurements (no mini-plot).</div>
      </section>

      <!-- Row 2: Kp chart above aurora -->
      <section class="card col-8">
        <h2>Kp Index, last ~4 days (3-hour bins)</h2>
        <canvas id="kp-chart"></canvas>
        <div class="sub">Shaded bands: Kp < 4 in green, Kp 4→9 transitions from yellow to red. Y-axis fixed 0–9.</div>
      </section>

      <section class="card col-8">
        <h2>OVATION Aurora (Nowcast)</h2>
        <div class="aurora">
          <img id="aurora-nh" alt="Aurora forecast, Northern Hemisphere" src="https://services.swpc.noaa.gov/images/animations/ovation/north/latest.jpg" />
        </div>
        <div class="sub">Images courtesy of NOAA SWPC. Green, yellow, red correspond to higher auroral probability.</div>
      </section>

      <!-- Row 3: E-field map -->
      <section class="card col-12">
        <h2>Geoelectric Field (US & Canada, regional 1-D)</h2>
        <div id="efield-map"><div id="efield-error" class="inline-error">E-field data unavailable. Retrying…</div></div>
        <div class="sub">Filled contours show |E| (mV/km) using an interpolated field; vectors show (Ex,Ey), scaled for visibility (not to geographic scale).</div>
      </section>

      <section class="card col-12">
        <div class="sub">Auto-refreshes every 60 seconds for text, 5 minutes for geoelectric map. Data from <a href="https://services.swpc.noaa.gov/" target="_blank" rel="noopener">services.swpc.noaa.gov</a>. All times show your local timezone.</div>
      </section>
    </div>
  </div>

  <script>
    // ---------- Utilities ----------
    const fmtTime = ts => new Date(ts).toLocaleString();

    function setUpdated(){
      document.getElementById('last-updated').textContent = 'Updated ' + new Date().toLocaleTimeString();
    }

    function badge(el, text, cls){
      const s = document.createElement('span');
      s.className = 'chip ' + (cls || '');
      s.textContent = text; el.appendChild(s);
    }

    function drawSpark(canvas, arr){
      const ctx = canvas.getContext('2d');
      const w = canvas.width = canvas.clientWidth * devicePixelRatio;
      const h = canvas.height = canvas.clientHeight * devicePixelRatio;
      ctx.clearRect(0,0,w,h);
      if(!arr || !arr.length) return;
      const min = Math.min(...arr), max = Math.max(...arr);
      const xstep = w / (arr.length - 1 || 1);
      ctx.lineWidth = 2 * devicePixelRatio; ctx.beginPath();
      arr.forEach((v,i)=>{
        const x = i * xstep;
        const y = h - ((v - min) / (max - min || 1)) * (h-4*devicePixelRatio) - 2*devicePixelRatio;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.strokeStyle = '#cfe1ff';
      ctx.stroke();
    }

    // ---------- Kp ----------
    async function loadKp(){
      const url = 'https://services.swpc.noaa.gov/products/noaa-planetary-k-index.json';
      const res = await fetch(url, {cache:'no-cache'});
      if(!res.ok) throw new Error('Kp HTTP '+res.status);
      const data = await res.json();
      const row = data[data.length-1];
      const when = row[0]; const kp = parseFloat(row[1]);
      document.getElementById('kp').textContent = kp.toFixed(1);
      document.getElementById('kp-time').textContent = 'as of ' + fmtTime(when);
      const badges = document.getElementById('kp-badges'); badges.innerHTML='';
      if (kp < 4) badge(badges,'Quiet','ok');
      else if (kp < 5) badge(badges,'Unsettled','warn');
      else if (kp < 6) badge(badges,'G1 Minor storm','warn');
      else if (kp < 7) badge(badges,'G2 Moderate','alert');
      else if (kp < 8) badge(badges,'G3 Strong','alert');
      else if (kp < 9) badge(badges,'G4 Severe','alert');
      else badge(badges,'G5 Extreme','alert');
    }

    function drawKpChart(canvas, series){
      const ctx = canvas.getContext('2d');
      const w = canvas.width = canvas.clientWidth * devicePixelRatio;
      const h = canvas.height = canvas.clientHeight * devicePixelRatio;
      ctx.clearRect(0,0,w,h);
      const padL = 40*devicePixelRatio, padR = 12*devicePixelRatio, padT = 10*devicePixelRatio, padB = 24*devicePixelRatio;
      const plotW = w - padL - padR, plotH = h - padT - padB;

      // Background bands
      ctx.save();
      const y0 = padT + (1 - (4/9)) * plotH; // Kp 4 split
      ctx.fillStyle = 'rgba(123,216,143,0.18)';
      ctx.fillRect(padL, y0, plotW, padT + plotH - y0);
      const grad = ctx.createLinearGradient(0, padT, 0, y0);
      grad.addColorStop(0, 'rgba(255,107,107,0.22)');
      grad.addColorStop(1, 'rgba(255,209,102,0.22)');
      ctx.fillStyle = grad; ctx.fillRect(padL, padT, plotW, y0 - padT);
      ctx.restore();

      // Axes + ticks
      ctx.strokeStyle = '#28466e'; ctx.lineWidth = 1 * devicePixelRatio; ctx.beginPath();
      ctx.moveTo(padL, padT); ctx.lineTo(padL, padT + plotH); ctx.lineTo(padL + plotW, padT + plotH); ctx.stroke();
      ctx.fillStyle = '#8aa0c2'; ctx.font = `${10*devicePixelRatio}px system-ui, sans-serif`;
      for(let yv=0; yv<=9; yv++){
        const y = padT + (1 - (yv/9)) * plotH;
        ctx.beginPath(); ctx.moveTo(padL, y); ctx.lineTo(padL + plotW, y); ctx.stroke();
        ctx.fillText(String(yv), padL - 20*devicePixelRatio, y + 3*devicePixelRatio);
      }

      if (!series || series.length === 0) return;
      const xs = series.map(d=>d.t); const minT = Math.min(...xs), maxT = Math.max(...xs);
      const xFor = t => padL + ((t - minT) / (maxT - minT || 1)) * plotW;
      const yFor = kp => padT + (1 - (Math.max(0, Math.min(9, kp)) / 9)) * plotH;
      ctx.lineWidth = 2 * devicePixelRatio; ctx.strokeStyle = '#cfe1ff'; ctx.beginPath();
      series.forEach((d,i)=>{ const x=xFor(d.t), y=yFor(d.kp); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); });
      ctx.stroke();

      // X tick labels ~daily
      const stepMs = 24*3600*1000; ctx.textAlign = 'center';
      for(let t=Math.ceil(minT/stepMs)*stepMs; t<=maxT; t+=stepMs){
        const x = xFor(t);
        ctx.fillText(new Date(t).toLocaleDateString(undefined,{month:'short', day:'2-digit'}), x, padT + plotH + 14*devicePixelRatio);
      }
    }

    async function loadKpSeries(){
      const url = 'https://services.swpc.noaa.gov/products/noaa-planetary-k-index.json';
      const res = await fetch(url, {cache:'no-cache'});
      if(!res.ok) throw new Error('Kp series HTTP '+res.status);
      const data = await res.json();
      const rows = data.slice(1);
      const series = rows.map(r=>({ t: new Date(r[0]).getTime(), kp: parseFloat(r[1]) })).filter(d=>isFinite(d.kp));
      drawKpChart(document.getElementById('kp-chart'), series.slice(-32));
    }

    // ---------- X-ray ----------
    function xrayClassFromFlux(flux){
      const levels = [ {thr:1e-4, letter:'X'}, {thr:1e-5, letter:'M'}, {thr:1e-6, letter:'C'}, {thr:1e-7, letter:'B'}, {thr:1e-8, letter:'A'} ];
      for(const l of levels){ if(flux >= l.thr) return l.letter + (flux / l.thr).toFixed(2); }
      return 'A0.00';
    }

    async function loadXray(){
      const url = 'https://services.swpc.noaa.gov/json/goes/primary/xrays-1-day.json';
      const res = await fetch(url, {cache:'no-cache'});
      if(!res.ok) throw new Error('Xray HTTP '+res.status);
      const data = await res.json();
      const points = data.filter(d=>Number.isFinite(Number(d.xrsb)));
      // Find max over last 24h
      let maxIdx = -1; let maxVal = -Infinity;
      for (let i=0;i<points.length;i++){
        const v = Number(points[i].xrsb);
        if (v>maxVal){ maxVal=v; maxIdx=i; }
      }
      if (maxIdx>=0){
        document.getElementById('xray-class').textContent = xrayClassFromFlux(maxVal);
        document.getElementById('xray-time').textContent = 'max in last 24h at ' + fmtTime(points[maxIdx].time_tag);
      } else {
        document.getElementById('xray-class').textContent = '—';
        document.getElementById('xray-time').textContent = 'no data';
      }
      // Keep sparkline for context (optional visual)
      drawSpark(document.getElementById('xray-spark'), points.map(p=>Number(p.xrsb)).slice(-180));
    }

    // ---------- Solar wind ----------
    async function loadSolarWind(){
      const plasmaUrl = 'https://services.swpc.noaa.gov/products/solar-wind/plasma-1-day.json';
      const magUrl = 'https://services.swpc.noaa.gov/products/solar-wind/mag-1-day.json';
      const [pRes, mRes] = await Promise.all([
        fetch(plasmaUrl, {cache:'no-cache'}),
        fetch(magUrl, {cache:'no-cache'})
      ]);
      if(!pRes.ok) throw new Error('Plasma HTTP '+pRes.status);
      if(!mRes.ok) throw new Error('Mag HTTP '+mRes.status);
      const plasma = await pRes.json();
      const mag = await mRes.json();
      const pRow = plasma[plasma.length-1];
      const mRow = mag[mag.length-1];
      const speed = parseFloat(pRow[2]);
      const density = parseFloat(pRow[1]);
      const bt = parseFloat(mRow[6]);
      const bz = parseFloat(mRow[7]);
      document.getElementById('sw-speed').textContent = isFinite(speed)? speed.toFixed(0): '—';
      document.getElementById('sw-density').textContent = isFinite(density)? density.toFixed(1): '—';
      document.getElementById('sw-bt').textContent = isFinite(bt)? bt.toFixed(1): '—';
      const bzEl = document.getElementById('sw-bz');
      if (isFinite(bz)){
        bzEl.textContent = bz.toFixed(1);
        bzEl.style.color = (bz < -3) ? 'var(--alert)' : (bz < 0 ? 'var(--warn)' : 'var(--ok)');
      } else {
        bzEl.textContent = '—';
      }
      // no sparkline requested in Solar Wind card
    }

    // ---------- Alerts (latest WARNING only) ----------
    function parseAlertTime(a){
      return new Date(a.issue_datetime || a.message_issue_datetime || a.event_begin || a.event_end || a.created_at || 0).getTime();
    }
    function isWarning(a){
      const t = (a.message_type || a.product_type || a.product_id || '').toString().toLowerCase();
      const msg = (a.message || a.summary || a.description || '').toString().toLowerCase();
      return t.includes('warning') || /\bwarning\b/.test(msg);
    }
    async function loadAlerts(){
      const url = 'https://services.swpc.noaa.gov/products/alerts.json';
      const res = await fetch(url, {cache:'no-cache'});
      if(!res.ok) throw new Error('Alerts HTTP '+res.status);
      const data = await res.json();
      const root = document.getElementById('alerts');
      root.innerHTML = '';
      const rows = Array.isArray(data) ? data.slice(1) : [];
      if(rows.length === 0){ root.textContent = 'No current alerts.'; return; }
      const latestWarning = rows.filter(isWarning).sort((a,b)=>parseAlertTime(a)-parseAlertTime(b)).pop();
      const item = latestWarning || rows.sort((a,b)=>parseAlertTime(a)-parseAlertTime(b)).pop();
      const when = fmtTime(item.issue_datetime || item.message_issue_datetime || item.event_begin);
      const cat = item.product_id || item.message_type || 'Alert';
      const txt = (item.message || item.summary || item.description || '').replace(/\n/g,'<br/>');
      const div = document.createElement('div');
      div.innerHTML = `<span class="chip">${cat}</span> <span class="sub">${when}</span><br/>${txt}`;
      root.appendChild(div);
    }

    // ---------- Geoelectric map (filled contours + vectors) ----------
    let efieldMap, efieldLayer, efieldVectors, legendCtl, efieldRaster;

    function initEfieldMap(){
      if (typeof L === 'undefined'){ console.error('Leaflet not loaded'); return; }
      if (efieldMap) return;
      efieldMap = L.map('efield-map', {zoomControl:true, attributionControl:true}).setView([50,-100], 4);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 9,
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(efieldMap);
      legendCtl = L.control({position:'bottomright'});
      legendCtl.onAdd = function(){
        const d = L.DomUtil.create('div', 'legend');
        d.innerHTML = `<div><strong>|E| (mV/km)</strong></div>
          <div><span class="swatch" style="background:#7bd88f"></span> < 1</div>
          <div><span class="swatch" style="background:#ffd166"></span> 1–2</div>
          <div><span class="swatch" style="background:#ff9f5a"></span> 2–4</div>
          <div><span class="swatch" style="background:#ff6b6b"></span> ≥ 4</div>
          <div style="margin-top:6px"><small>Contours from interpolated |E|; arrows show (Ex,Ey) direction.</small></div>`;
        return d;
      };
      legendCtl.addTo(efieldMap);
      efieldVectors = L.layerGroup().addTo(efieldMap);
    }

    function eColor(m){
      if (m == null || !isFinite(m)) return '#8aa0c2';
      if (m < 1) return '#7bd88f';
      if (m < 2) return '#ffd166';
      if (m < 4) return '#ff9f5a';
      return '#ff6b6b';
    }

    function inferMagnitude(props){
      const candidates = [
        props && (props.magnitude ?? props.mag ?? props.E ?? props['|E|'] ?? props.absE),
        (props && props.Ex!=null && props.Ey!=null) ? Math.hypot(props.Ex, props.Ey) : null,
        (props && props.E_east_west!=null && props.E_north_south!=null) ? Math.hypot(props.E_east_west, props.E_north_south) : null,
        (props && props.ew!=null && props.ns!=null) ? Math.hypot(props.ew, props.ns) : null
      ];
      return candidates.find(v=>v!=null && isFinite(v)) ?? null;
    }

    function inferVector(props){
      if (!props) return null;
      if (props.Ex!=null && props.Ey!=null) return [Number(props.Ex), Number(props.Ey)];
      if (props.E_east_west!=null && props.E_north_south!=null) return [Number(props.E_east_west), Number(props.E_north_south)];
      if (props.ew!=null && props.ns!=null) return [Number(props.ew), Number(props.ns)];
      return null;
    }

    function normalizeToFeatureCollection(gj){
      if (!gj) return null;
      if (gj.type === 'FeatureCollection') return gj;
      if (gj.type === 'Feature') return {type:'FeatureCollection', features:[gj]};
      return {type:'FeatureCollection', features:[{type:'Feature', geometry:gj, properties:{}}]};
    }

    function pointToLayer(feature, latlng){
      // Invisible anchor points (no dots), used only for vector placement.
      return L.circleMarker(latlng, {
        radius: 0,
        color: 'transparent',
        weight: 0,
        fillOpacity: 0,
        opacity: 0,
        interactive: false
      });
    }

    function calcStride(n, maxArrows=200){
      return Math.max(1, Math.ceil(n / Math.max(1,maxArrows)));
    }

    function drawVectorsFromLayer(layer){
      efieldVectors.clearLayers();
      const children = [];
      layer.eachLayer(l=>children.push(l));
      const stride = calcStride(children.length, 180); // aim ~180 arrows max
      const takenCells = new Set();
      const cellSize = 1.2; // degrees
      let i=0;
      for (const child of children){
        if ((i++ % stride) !== 0) continue;
        let center;
        if (child.getLatLng) center = child.getLatLng();
        else if (child.getBounds) center = child.getBounds().getCenter();
        if (!center) continue;
        const key = Math.round(center.lat/cellSize)+','+Math.round(center.lng/cellSize);
        if (takenCells.has(key)) continue;
        const props = (child.feature && child.feature.properties) || {};
        const vec = inferVector(props);
        if (!vec) continue;
        const ex = Number(vec[0]);
        const ey = Number(vec[1]);
        const mag = Math.hypot(ex,ey);
        if (!isFinite(mag) || mag===0) continue;
        const scale = 0.08;
        const dLat = ey * scale;
        const dLon = ex * scale / Math.max(0.3, Math.cos(center.lat * Math.PI/180));
        const end = L.latLng(center.lat + dLat, center.lng + dLon);
        const line = L.polyline([center, end], {color:'#cfe1ff', weight:1.3, opacity:0.9});
        const back = L.latLng(end.lat - 0.2*dLat + 0.08*dLon, end.lng - 0.2*dLon - 0.08*dLat);
        const back2 = L.latLng(end.lat - 0.2*dLat - 0.08*dLon, end.lng - 0.2*dLon + 0.08*dLat);
        const head1 = L.polyline([back, end], {color:'#cfe1ff', weight:1.3, opacity:0.9});
        const head2 = L.polyline([back2, end], {color:'#cfe1ff', weight:1.3, opacity:0.9});
        efieldVectors.addLayer(line); efieldVectors.addLayer(head1); efieldVectors.addLayer(head2);
        takenCells.add(key);
      }
    }

    function collectEfieldSamples(geojson){
      const samples = [];
      if (!geojson || !geojson.features) return samples;
      for (const f of geojson.features){
        const g = f.geometry;
        if (!g) continue;
        let latlng = null;
        if (g.type === 'Point'){
          latlng = L.latLng(g.coordinates[1], g.coordinates[0]);
        } else if (g.type === 'Polygon' && g.coordinates && g.coordinates[0] && g.coordinates[0].length){
          const ring = g.coordinates[0];
          let latSum=0, lonSum=0, n=0;
          for (const c of ring){ lonSum+=c[0]; latSum+=c[1]; n++; }
          if (n>0) latlng = L.latLng(latSum/n, lonSum/n);
        }
        if (!latlng) continue;
        const mag = inferMagnitude(f.properties || {});
        if (mag!=null && isFinite(mag)) samples.push({latlng, mag});
      }
      return samples;
    }

    function drawFilledContours(samples, map){
      if (!samples || !samples.length) return null;
      const size = map.getSize();
      const canvas = document.createElement('canvas');
      canvas.width = size.x;
      canvas.height = size.y;
      const ctx = canvas.getContext('2d');
      const bounds = map.getBounds();

      const gridStep = 24; // px
      for (let x = 0; x < size.x; x += gridStep){
        for (let y = 0; y < size.y; y += gridStep){
          const latlng = map.containerPointToLatLng([x + gridStep/2, y + gridStep/2]);
          let num = 0, den = 0;
          for (const p of samples){
            const dist = map.distance(latlng, p.latlng) || 1e-3;
            const w = 1 / (dist * dist);
            num += w * p.mag;
            den += w;
          }
          const val = den>0 ? num/den : samples[0].mag;
          ctx.fillStyle = eColor(val);
          ctx.fillRect(x, y, gridStep+1, gridStep+1);
        }
      }

      const imgUrl = canvas.toDataURL('image/png');
      return L.imageOverlay(imgUrl, bounds, {opacity:0.6});
    }

    async function getLatestGeojsonUrl(){
      const base = 'https://services.swpc.noaa.gov/json/lists/rgeojson/US-Canada-1D/';
      const res = await fetch(base, {cache:'no-cache'});
      if(!res.ok) throw new Error('List HTTP '+res.status);
      const text = await res.text();
      let data = null; let names = [];
      try{ data = JSON.parse(text); } catch(_){ /* plain text */ }
      if (data){
        const arr = Array.isArray(data) ? data : (Array.isArray(data.files)? data.files : (Array.isArray(data.items)? data.items : []));
        names = arr.map(x=> typeof x==='string'? x : (x && (x.name||x.file||x.url||x.href||x[0]))).filter(Boolean);
      } else {
        const re = /[A-Za-z0-9_.-]+\.(?:geo)?json/g; let m; while((m = re.exec(text))!==null){ names.push(m[0]); }
      }
      const filtered = names.filter(n=>/\.(?:geo)?json$/i.test(n)).sort();
      if (filtered.length){
        const fname = filtered[filtered.length-1];
        return fname.startsWith('http') ? fname : base + encodeURIComponent(fname);
      }
      for (const last of ['latest.geojson','latest.json']){
        const trial = base + last;
        const head = await fetch(trial, {method:'HEAD', cache:'no-cache'});
        if (head.ok) return trial;
      }
      throw new Error('No *.json file found');
    }

    async function loadEfieldGeoJSON(){
      const errorEl = document.getElementById('efield-error');
      try{
        if (typeof L === 'undefined') throw new Error('Leaflet not loaded');
        if (!efieldMap) initEfieldMap();
        const geoUrl = await getLatestGeojsonUrl();
        const gjRes = await fetch(geoUrl, {cache:'no-cache'});
        if(!gjRes.ok) throw new Error('GeoJSON HTTP '+gjRes.status+` @ ${geoUrl}`);
        let gj = await gjRes.json();
        gj = normalizeToFeatureCollection(gj);
        if (!gj || !gj.features) throw new Error('Malformed GeoJSON payload');

        if (efieldLayer) { efieldLayer.remove(); efieldLayer = null; }
        if (efieldRaster) { efieldRaster.remove(); efieldRaster = null; }

        efieldLayer = L.geoJSON(gj, {
          style: f => ({
            color: 'transparent',
            weight: 0,
            fillOpacity: 0
          }),
          pointToLayer,
          onEachFeature: (feature, layer) => {
            if (feature && feature.geometry && feature.geometry.type === 'Point') return;
            const p = feature.properties || {};
            const mag = inferMagnitude(p);
            const ts = p.time || p.timestamp || p.valid || p.iso_time || '';
            const label = `|E| ≈ ${mag!=null? Number(mag).toFixed(2):'—'} mV/km`;
            const extra = Object.entries(p).slice(0,12).map(([k,v])=>`<div><small>${k}: ${v}</small></div>`).join('');
            layer.bindPopup(`<strong>Geoelectric Field</strong><div>${label}</div><div><small>${ts}</small></div>${extra}`);
          }
        }).addTo(efieldMap);

        // Filled contour raster
        const samples = collectEfieldSamples(gj);
        if (samples.length){
          efieldRaster = drawFilledContours(samples, efieldMap);
        }

        // Vectors
        drawVectorsFromLayer(efieldLayer);

        try{
          const b = efieldLayer.getBounds();
          if (b && b.isValid()) efieldMap.fitBounds(b, {padding:[20,20]});
        } catch(_){ }
        errorEl.style.display = 'none';
      } catch(e){
        console.error('E-field load error', e);
        if (errorEl){
          errorEl.style.display = 'block';
          errorEl.textContent = 'E-field data unavailable. ' + e.message + ' Retrying…';
        }
      }
    }

    async function refresh(){
      try{ await Promise.all([loadKp(), loadKpSeries(), loadXray(), loadSolarWind(), loadAlerts()]); }
      catch(e){ console.error(e); }
      finally{ setUpdated(); }
    }

    function refreshAuroraImages(){
      const t = Date.now();
      for (const id of ['aurora-nh']){
        const img = document.getElementById(id);
        const base = img.src.split('?')[0];
        img.src = base + '?_=' + t;
      }
    }

    // ---------- Runtime tests ----------
    (function runtimeTests(){
      // Leaflet presence
      console.assert(typeof L !== 'undefined', 'Leaflet should be loaded before app script');
      // Alert filtering: pick last warning
      const rows = [
        {message_type:'Watch', issue_datetime:'2024-01-01T00:00:00Z'},
        {message_type:'Warning', issue_datetime:'2024-01-01T01:00:00Z'},
        {message_type:'Warning', issue_datetime:'2024-01-01T02:00:00Z'}
      ];
      const latest = rows
        .filter(r=> (r.message_type||'').toLowerCase().includes('warning'))
        .sort((a,b)=> new Date(a.issue_datetime)-new Date(b.issue_datetime))
        .pop();
      console.assert(latest && latest.issue_datetime==='2024-01-01T02:00:00Z', 'latest warning selector');
      // Vector inference
      console.assert(JSON.stringify(inferVector({Ex:2,Ey:0}))==='[2,0]', 'inferVector Ex/Ey');
      console.assert(JSON.stringify(inferVector({ew:-1,ns:3}))==='[-1,3]', 'inferVector ew/ns');
      // List parser: JSON and plaintext
      (function(){
        const sampleText = `index of files\nfoo.txt\nbar.geojson\n2024-01-01.json\n`;
        const re = /[A-Za-z0-9_.-]+\.(?:geo)?json/g;
        const matches = [...sampleText.matchAll(re)].map(m=>m[0]);
        console.assert(matches.includes('bar.geojson') && matches.includes('2024-01-01.json'), 'plaintext list regex');
      })();
      // Stride calculator tests (sparsity)
      console.assert(calcStride(10,180)===1, 'stride small n');
      console.assert(calcStride(1000,200)===5, 'stride large n');
      // X-ray max pick test
      (function(){
        const mock = [
          {time_tag:'2025-01-01T00:00:00Z', xrsb:'1e-7'},
          {time_tag:'2025-01-01T01:00:00Z', xrsb:'3e-6'},
          {time_tag:'2025-01-01T02:00:00Z', xrsb:'2e-6'}
        ];
        let maxIdx=-1,maxVal=-Infinity;
        for (let i=0;i<mock.length;i++){
          const v=Number(mock[i].xrsb);
          if(v>maxVal){maxVal=v;maxIdx=i;}
        }
        console.assert(maxIdx===1 && xrayClassFromFlux(maxVal).startsWith('C'), 'x-ray max class selection');
      })();
      // Sample collection test
      (function(){
        const mockGj = {
          type:'FeatureCollection',
          features:[
            {type:'Feature', geometry:{type:'Point', coordinates:[-100,50]}, properties:{Ex:1,Ey:1}},
            {type:'Feature', geometry:{type:'Polygon', coordinates:[[[0,0],[1,0],[1,1],[0,1],[0,0]]]}, properties:{magnitude:2}}
          ]
        };
        const s = collectEfieldSamples(mockGj);
        console.assert(s.length===2 && s[0].latlng && s[1].latlng, 'collectEfieldSamples basic');
      })();
    })();

    // ---------- Kickoff/refresh ----------
    refresh();
    refreshAuroraImages();
    setInterval(refresh, 60*1000);
    setInterval(refreshAuroraImages, 60*1000);
    loadEfieldGeoJSON();
    setInterval(loadEfieldGeoJSON, 5*60*1000);
  </script>
</body>
</html>
